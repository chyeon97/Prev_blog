---
layout: single
title: "가비지 컬렉터"
categories: Javascript
tag: [Javascript, GC, 자바스크립트 가비지컬렉터, 가비지컬렉터]
toc: true
toc_sticky: true
---

## 이 글에서 알 수 있는 내용

- 가비지컬렉터 정의
- 가비지컬렉터의 장단점
- 가비지컬렉터 알고리즘

## 가비지컬렉터란?

> 메모리 할당을 추적하고 할당된 메모리 영역이 **더 이상 필요하지 않는 경우**를 판단하여 **알아서 회수**하는 것

## 장단점

### 장점😀

- 메모리 누수 방지
- 해제된 메모리 접근 방지
- 이미 해제한 메모리를 다시 해제하는 이중 해제 방지

### 단점😣

- 어떠한 메모리 영역이 해제의 대상이 될지 검사하고 해제하는 일은 프로그램 실행의 방해가 되는 순수 오버헤드
- 개발자는 언제 GC가 메모리를 해제하는지 모름 🤷🏻‍♂️

## 알고리즘

### Reference-counting

> "더 이상 필요없는 객체"를 "어떤 다른 객체도 참조하지 않는 객체"라고 정의  
> ➡︎ **특정 객체를 참조하는 객체가 하나도 없으면, 그 특정 객체에 대해 가비지 컬렉션을 수행함**

#### 순환 참조로 인한 한계점

> 순환 참조는 두 객체가 서로를 참조하는 경우를 뜻하며, 가바지컬렉터가 수행되지 않아 메모리 누수가 발생함

```javascript
function f() {
  var x = {};
  var y = {};

  x.a = y; // x의 속성 a가 y에 담긴 객체를 참조함
  y.a = x; // y의 속성 a가 x에 담긴 객체를 참조함
  return "test";
}
f();
```

f()가 종료되면 x,y에 저장한 객체는 사용되지 않으므로 가비지 컬렉션이 수행되어야 함.  
하지만, x와 y 객체 모두 참조를 가지고 있기때문에 가비지 컬렉션이 수행되지 않음 ➡︎ 메모리 누수 발생

### Mark and Sweap

> "더 이상 필요 없는 객체"를 "더 이상 접근할 수 없는 객체"로 정의함  
> ➡︎ 접근할 수 없는(닿을수 없는) 객체일 때, 가비지 컬렉션을 수행함

#### 간단한 동작 방식

```javascript
{
  var x = {};
  var y = {};

  x.a = y; // x의 속성 a가 y에 담긴 객체를 참조함
  y.a = x; // y의 속성 a가 x에 담긴 객체를 참조함
}
```

① 선언된 객체를 선언한 출처와 연결을 해줌(그래프 형식)  
② 가비지컬렉터 실행  
③ 그래프를 순회하며 연결된 객체에 Marking를 함(**<span style="color:green">Mark</span>**)  
④ 객체 전체를 순서대로 Marking 여부를 확인하여 Marking이 되어있지 않은 객체를 GC 대상으로 판단함(**<span style="color:gray">Sweap</span>**)

<img src="https://user-images.githubusercontent.com/40657327/144703666-155cd765-ec02-4ed5-acf7-0a49900f87fd.png">

#### 한계점

> 매번 선언된 객체 전체를 다 훑어야 하므로 복잡한 프로그램을 사용하면 이로 인해 프로그램 멈춤 현상이 발생할 수 있음
